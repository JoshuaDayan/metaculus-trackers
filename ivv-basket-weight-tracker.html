<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Companies Weight Tracker | Metaculus</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }

        .container { max-width: 1600px; margin: 0 auto; }

        /* Top navigation (shared style) */
        .top-nav {
            position: sticky;
            top: 10px;
            z-index: 1100;
            margin-bottom: 18px;
        }

        .top-nav-inner {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
            padding: 12px 16px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 14px;
            backdrop-filter: blur(10px);
        }

        .brand {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            color: #e0e0e0;
            font-weight: 800;
            font-size: 0.9rem;
            white-space: nowrap;
            text-decoration: none;
        }

        .brand-mark {
            width: 12px;
            height: 28px;
            border-radius: 7px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
        }

        .nav-tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav-tab {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 9px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.20);
            color: #cfd6e6;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            transition: all 0.15s ease;
        }

        .nav-tab:hover {
            transform: translateY(-1px);
            border-color: rgba(255,255,255,0.16);
            background: rgba(255,255,255,0.06);
        }

        .nav-tab.active {
            background: rgba(0, 212, 255, 0.14);
            border-color: rgba(0, 212, 255, 0.35);
            color: #9ff0ff;
        }

        .nav-actions { position: relative; display: flex; align-items: center; gap: 10px; }
        .nav-btn { appearance: none; }
        .dropdown {
            position: absolute;
            top: calc(100% + 10px);
            right: 0;
            min-width: 240px;
            background: rgba(10, 12, 26, 0.98);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 14px;
            padding: 10px;
            box-shadow: 0 18px 50px rgba(0,0,0,0.45);
        }
        .dropdown-title { color: #888; font-size: 0.75rem; font-weight: 800; letter-spacing: 0.6px; text-transform: uppercase; padding: 6px 8px 8px; }
        .dropdown-subtitle { color: #888; font-size: 0.78rem; padding: 0 8px 10px; line-height: 1.35; }
        .menu-item {
            width: 100%;
            padding: 10px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.04);
            color: #cfd6e6;
            text-decoration: none;
            cursor: pointer;
            font-size: 0.85rem;
            text-align: left;
        }
        .menu-item:hover { border-color: rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); }
        .menu-item.primary {
            background: rgba(0, 212, 255, 0.12);
            border-color: rgba(0, 212, 255, 0.25);
            color: #9ff0ff;
            font-weight: 900;
        }
        .menu-hint { color: #888; font-size: 0.75rem; margin-left: 8px; }

        @media (max-width: 768px) {
            .top-nav { top: 0; }
            .top-nav-inner { flex-wrap: wrap; justify-content: center; }
            .brand { width: 100%; justify-content: center; }
            .nav-actions { width: 100%; justify-content: center; }
            .dropdown { right: 50%; transform: translateX(50%); }
        }

        header {
            text-align: center;
            margin-bottom: 18px;
            padding: 22px;
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle { color: #888; font-size: 0.9rem; margin-bottom: 5px; }
        .subtitle a { color: #00d4ff; text-decoration: underline; text-underline-offset: 2px; }
        .subtitle a:hover { text-decoration-thickness: 2px; }
        .subtitle a .ext { font-size: 0.85em; opacity: 0.8; margin-left: 6px; }
        .subtitle a:hover .ext { opacity: 1; }

        .foundation-subtitle {
            font-family: 'Cinzel', serif;
            font-size: 0.75rem;
            color: #b8860b;
            margin-top: 15px;
            padding: 10px 20px;
            background: linear-gradient(135deg, rgba(184, 134, 11, 0.1), rgba(218, 165, 32, 0.05));
            border: 1px solid rgba(184, 134, 11, 0.3);
            border-radius: 8px;
            letter-spacing: 1px;
            display: inline-block;
        }

        .question-box {
            background: rgba(123, 44, 191, 0.1);
            border: 1px solid rgba(123, 44, 191, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.85rem;
            color: #ccc;
            text-align: left;
            margin-left: auto;
            margin-right: auto;
            max-width: 860px;
        }

        .question-box strong { color: #00d4ff; }
        .question-box a { color: #00d4ff; text-decoration: none; }
        .question-box a:hover { text-decoration: underline; }

        .meta {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 999px;
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.10);
            font-size: 0.85rem;
            color: #cfd6e6;
        }

        .pill strong { color: #9ff0ff; }
        .pill code { color: #fbbf24; font-weight: 700; }

        .cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 14px;
            margin-bottom: 16px;
        }

        .card {
            padding: 16px;
            border-radius: 14px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.10);
        }

        .card-title { color: #888; font-size: 0.8rem; margin-bottom: 8px; }
        .card-value { font-size: 1.8rem; font-weight: 900; }
        .card-sub { margin-top: 6px; color: #aaa; font-size: 0.85rem; }

        .row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 14px;
            align-items: start;
        }

        body.advanced-open .row { grid-template-columns: 1.35fr 0.65fr; }

        @media (max-width: 1100px) {
            .row { grid-template-columns: 1fr; }
            body.advanced-open .row { grid-template-columns: 1fr; }
        }

        .panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 16px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .panel h2 { font-size: 1rem; color: #fff; }
        .note { color: #888; font-size: 0.82rem; margin-top: 8px; }
        .note a { color: #00d4ff; text-decoration: underline; text-underline-offset: 2px; }
        .note a:hover { text-decoration-thickness: 2px; }

        .btns { display: inline-flex; gap: 8px; flex-wrap: wrap; }
        .btns button {
            appearance: none;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.20);
            color: #cfd6e6;
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 800;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .btns button:hover { transform: translateY(-1px); background: rgba(255,255,255,0.06); }
        .btns button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .chart-wrap { height: 360px; }
        canvas { width: 100% !important; height: 100% !important; }

        .advanced-only { display: none !important; }
        body.advanced-open .advanced-only { display: block !important; }

        table {
            width: 100%;
            border-collapse: collapse;
            overflow: hidden;
            border-radius: 12px;
        }

        th, td {
            text-align: left;
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            font-size: 0.9rem;
        }

        th { color: #9ff0ff; font-size: 0.8rem; letter-spacing: 0.5px; text-transform: uppercase; }
        td code { color: #fbbf24; font-weight: 900; }

        .muted { color: #888; }

        .select {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        select {
            background: rgba(0,0,0,0.25);
            color: #e0e0e0;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 10px;
            padding: 8px 10px;
            font-weight: 800;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <nav class="top-nav" aria-label="Primary">
        <div class="top-nav-inner">
            <div class="brand" aria-label="Site">
                <div class="brand-mark" aria-hidden="true"></div>
                <div>Bund &amp; Currency Trackers</div>
            </div>

            <div class="nav-tabs" role="navigation" aria-label="Pages">
                <a class="nav-tab" href="february-2026-currency-tracker.html">Currency</a>
                <a class="nav-tab" href="german-bond-tracker.html">Bond</a>
                <a class="nav-tab" href="brent-wti-spread-tracker.html">Oil</a>
                <a class="nav-tab active" href="ivv-basket-weight-tracker.html">IVV Basket</a>
            </div>

            <div class="nav-actions">
                <button class="nav-tab nav-btn" id="advancedBtn" type="button" aria-haspopup="menu" aria-expanded="false">View ‚ñæ</button>
                <div class="dropdown" id="advancedMenu" role="menu" hidden>
                    <div class="dropdown-title">View</div>
                    <div class="dropdown-subtitle">Basic = headline + history chart. Full = weights, projection, sources (remembers your choice).</div>
                    <button class="menu-item primary" type="button" data-advanced-toggle>Full dashboard</button>
                    <button class="menu-item" type="button" data-advanced-jump="weightsPanel">Latest weights <span class="menu-hint">‚Üò</span></button>
                    <button class="menu-item" type="button" data-advanced-jump="projectionPanel">Projections <span class="menu-hint">‚Üò</span></button>
                    <button class="menu-item" type="button" data-advanced-jump="verify">Wordcel comment <span class="menu-hint">‚Üò</span></button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container">

        <header>
            <h1>üìà AI Companies‚Äô S&amp;P 500 Weight Tracker</h1>
            <p class="subtitle">
                <a href="https://www.metaculus.com/questions/41341/ai-companies-sp-500-weight-on-feb-27-2026/" target="_blank" rel="noopener noreferrer">
                    Metaculus Question: AI companies‚Äô S&amp;P 500 weight on Feb 27, 2026
                    <span class="ext" aria-hidden="true">‚Üó</span>
                </a>
            </p>
	            <div class="foundation-subtitle">
	                Funding provided by the Ben Shindel Memorial Foundation<br>For Superforecasters Who Can't Predict Good
	            </div>

	            <div class="question-box advanced-only">
	                <strong>Resolution:</strong> Basket weight in IVV holdings as of Feb 27, 2026 (iShares snapshot).<br>
	                <strong>Formula:</strong> <code>BasketWeight% = Œ£ Weight%(ticker)</code> (basket shown above).
	            </div>
            <div class="meta">
                <div class="pill">Resolution date: <strong id="resolutionDatePill">2026-02-27</strong></div>
                <div class="pill">Question period start: <strong id="periodStartPill">2026-02-01</strong></div>
                <div class="pill">Basket: <code>NVDA</code> <code>MSFT</code> <code>GOOGL</code> <code>GOOG</code> <code>AMZN</code> <code>META</code> <code>AMD</code></div>
                <div class="pill">Last updated: <strong id="lastUpdated">Loading‚Ä¶</strong></div>
            </div>
        </header>

        <section class="cards">
            <div class="card">
                <div class="card-title">Current basket weight</div>
                <div class="card-value" id="currentTotal">‚Äî</div>
                <div class="card-sub muted" id="currentAsOf">As of ‚Äî</div>
            </div>
            <div class="card">
                <div class="card-title">Live basket weight (est.)</div>
                <div class="card-value" id="liveBasketNow">‚Äî</div>
                <div class="card-sub muted" id="liveBasketNote">Updates every 60s</div>
            </div>
            <div class="card">
                <div class="card-title">Change since period start</div>
                <div class="card-value" id="changeSinceStart">‚Äî</div>
                <div class="card-sub muted" id="startValueNote">Start value ‚Äî</div>
            </div>
            <div class="card">
                <div class="card-title">Time to resolution</div>
                <div class="card-value" id="daysToResolution">‚Äî</div>
                <div class="card-sub muted" id="targetAvailability">Target holdings ‚Äî</div>
            </div>
        </section>

        <section class="row">
            <div class="panel">
                <div class="panel-header">
                    <h2>Live basket weight (estimated, pre/after-hours)</h2>
                </div>
                <div class="chart-wrap" style="height: 320px;">
                    <canvas id="liveChart"></canvas>
                </div>
                <div class="note" id="liveNote">Loading live prices‚Ä¶</div>
            </div>
        </section>

        <section class="row">
            <div class="panel">
                <div class="panel-header">
                    <h2>Basket weight (last 6 months)</h2>
                    <div class="btns">
                        <button id="zoomToPeriodBtn" type="button" disabled>Zoom to question period</button>
                        <button id="resetZoomBtn" type="button" disabled>Reset zoom</button>
                        <button id="downloadHistoryBtn" type="button" disabled>Download CSV</button>
                    </div>
                </div>
                <div class="chart-wrap">
                    <canvas id="historyChart"></canvas>
                </div>
                <div class="note" id="historyNote"></div>
            </div>

            <div class="panel advanced-only" id="weightsPanel">
                <div class="panel-header">
                    <h2>Latest weights</h2>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Ticker</th>
                            <th>Weight</th>
                        </tr>
                    </thead>
                    <tbody id="weightsTableBody">
                        <tr><td colspan="2" class="muted">Loading‚Ä¶</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="panel advanced-only" id="projectionPanel" style="margin-top: 14px;">
            <div class="panel-header">
                <h2>Projections to resolution</h2>
                <div class="select">
                    <label class="muted" for="projectionModel">Model</label>
                    <select id="projectionModel">
                        <option value="linear">Linear regression (lookback 60d)</option>
                        <option value="exp">Exponential trend (lookback 60d)</option>
                        <option value="mc">Monte Carlo (deltas, lookback 60d)</option>
                    </select>
                </div>
            </div>
            <div class="chart-wrap" style="height: 340px;">
                <canvas id="projectionChart"></canvas>
            </div>
            <div class="note muted" id="projectionNote">
                Projections are naive and for visualization only (not investment advice).
            </div>
        </section>

        <section class="panel advanced-only" id="verify" style="margin-top: 14px;">
            <div class="panel-header">
                <h2>Wordcel Statistician‚Äôs Comment</h2>
            </div>
            <div class="note">
                This tracker sums the basket‚Äôs <code>Weight (%)</code> from the daily iShares IVV holdings CSV snapshot.
                If a ticker is missing on a given day, it is treated as <code>0</code>; if <em>none</em> of the basket tickers appear,
                that date is skipped as ‚Äúnot available‚Äù.
            </div>
            <div class="note" id="samplingNote"></div>
            <div class="note">
                Want to verify manually? Download IVV holdings and check the <code>Weight (%)</code> column:
                <a href="https://www.ishares.com/us/products/239726/ishares-core-sp-500-etf" target="_blank" rel="noopener noreferrer">iShares IVV ‚Üó</a>
            </div>
        </section>
    </div>

    <script>
        const RESOLUTION_DATE = '2026-02-27';
        const QUESTION_PERIOD_START = '2026-02-01';
        const DEFAULT_TICKERS = ['NVDA', 'MSFT', 'GOOGL', 'GOOG', 'AMZN', 'META', 'AMD'];
        const LIVE_REFRESH_MS = 60_000;

        function parseISODate(dateStr) {
            const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateStr);
            if (!m) return null;
            const year = Number(m[1]);
            const month = Number(m[2]);
            const day = Number(m[3]);
            const date = new Date(Date.UTC(year, month - 1, day));
            if (date.getUTCFullYear() !== year || date.getUTCMonth() !== month - 1 || date.getUTCDate() !== day) return null;
            return date;
        }

        function toISODate(date) {
            return date.toISOString().slice(0, 10);
        }

        function addDays(date, days) {
            const d = new Date(date.getTime());
            d.setUTCDate(d.getUTCDate() + days);
            return d;
        }

        function isWeekday(date) {
            const day = date.getUTCDay();
            return day >= 1 && day <= 5;
        }

        function formatMonthDay(isoDate) {
            const d = parseISODate(isoDate);
            if (!d) return isoDate;
            return d.toLocaleDateString('en-US', { timeZone: 'UTC', month: 'short', day: '2-digit' });
        }

        function formatMonthDayYear(isoDate) {
            const d = parseISODate(isoDate);
            if (!d) return isoDate;
            return d.toLocaleDateString('en-US', { timeZone: 'UTC', month: 'short', day: '2-digit', year: 'numeric' });
        }

        function formatIntradayLabel(iso) {
            const d = new Date(iso);
            if (Number.isNaN(d.getTime())) return '';
            return d.toLocaleString('en-US', { timeZone: 'UTC', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' });
        }

        function formatPct(v) {
            if (v === null || v === undefined || !Number.isFinite(Number(v))) return '‚Äî';
            return `${Number(v).toFixed(2)}%`;
        }

        function formatSignedPctPoints(v) {
            if (v === null || v === undefined || !Number.isFinite(Number(v))) return '‚Äî';
            const n = Number(v);
            const sign = n >= 0 ? '+' : '';
            return `${sign}${n.toFixed(2)} pp`;
        }

        function clampLabelAfter(labels, target) {
            if (!labels.length) return null;
            for (const l of labels) if (l >= target) return l;
            return labels[0];
        }

        function clampLabelBefore(labels, target) {
            if (!labels.length) return null;
            for (let i = labels.length - 1; i >= 0; i -= 1) {
                if (labels[i] <= target) return labels[i];
            }
            return labels[labels.length - 1];
        }

        function labelForCategoryTick(labels, tickValue) {
            if (typeof tickValue === 'string') return tickValue;
            const idx = Number(tickValue);
            if (Number.isFinite(idx) && Array.isArray(labels) && idx >= 0 && idx < labels.length) {
                return labels[idx];
            }
            return String(tickValue);
        }

        function generateBusinessDates(startIsoExclusive, endIsoInclusive) {
            const start = parseISODate(startIsoExclusive);
            const end = parseISODate(endIsoInclusive);
            if (!start || !end) return [];
            if (end <= start) return [];
            const out = [];
            let cur = addDays(start, 1);
            while (cur <= end) {
                if (isWeekday(cur)) out.push(toISODate(cur));
                cur = addDays(cur, 1);
            }
            return out;
        }

        function csvEscape(value) {
            const s = String(value ?? '');
            if (/[\",\\n]/.test(s)) return '"' + s.replace(/\"/g, '""') + '"';
            return s;
        }

        function downloadCsv(filename, rows) {
            const csv = rows.map(r => r.map(csvEscape).join(',')).join('\\n') + '\\n';
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        function olsFit(xs, ys) {
            const n = xs.length;
            if (n < 2) return { a: ys[0] ?? 0, b: 0 };
            let sumX = 0, sumY = 0;
            for (let i = 0; i < n; i += 1) { sumX += xs[i]; sumY += ys[i]; }
            const meanX = sumX / n;
            const meanY = sumY / n;
            let cov = 0, varX = 0;
            for (let i = 0; i < n; i += 1) {
                const dx = xs[i] - meanX;
                cov += dx * (ys[i] - meanY);
                varX += dx * dx;
            }
            if (varX === 0) return { a: meanY, b: 0 };
            const b = cov / varX;
            const a = meanY - b * meanX;
            return { a, b };
        }

        function computeLinearProjection(history, futureSteps, lookback) {
            const n = history.length;
            const k = Math.max(2, Math.min(lookback, n));
            const slice = history.slice(n - k);
            const xs = slice.map((_, i) => i);
            const ys = slice.map(v => Number(v));
            const lastActual = Number(history[n - 1]);
            const fit = olsFit(xs, ys);
            const predLast = fit.a + fit.b * (k - 1);
            const a = fit.a + (lastActual - predLast);
            const b = fit.b;
            return Array.from({ length: futureSteps }, (_, step) => a + b * ((k - 1) + (step + 1)));
        }

        function computeExpProjection(history, futureSteps, lookback) {
            const n = history.length;
            const k = Math.max(2, Math.min(lookback, n));
            const slice = history.slice(n - k).map(v => Number(v));
            const xs = slice.map((_, i) => i);
            const ys = slice.map(v => (v > 0 ? Math.log(v) : null)).filter(v => v !== null);
            if (ys.length < 2) return computeLinearProjection(history, futureSteps, lookback);
            // Align xs with non-null ys.
            const xs2 = [];
            const ys2 = [];
            for (let i = 0; i < slice.length; i += 1) {
                const v = slice[i];
                if (v > 0) { xs2.push(i); ys2.push(Math.log(v)); }
            }
            const fit = olsFit(xs2, ys2);
            const A = Math.exp(fit.a);
            const kRate = fit.b;
            const lastActual = Number(history[n - 1]);
            const predLast = A * Math.exp(kRate * (k - 1));
            const scale = predLast > 0 ? (lastActual / predLast) : 1;
            const A2 = A * scale;
            return Array.from({ length: futureSteps }, (_, step) => A2 * Math.exp(kRate * ((k - 1) + (step + 1))));
        }

        function randn() {
            // Box-Muller transform
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function meanStd(values) {
            const n = values.length;
            if (!n) return { mean: 0, std: 0 };
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const var_ = values.reduce((a, b) => a + (b - mean) * (b - mean), 0) / Math.max(1, n - 1);
            return { mean, std: Math.sqrt(var_) };
        }

        function quantile(sortedArr, q) {
            if (!sortedArr.length) return null;
            const idx = Math.floor(q * (sortedArr.length - 1));
            return sortedArr[Math.max(0, Math.min(sortedArr.length - 1, idx))];
        }

        function computeMonteCarlo(history, futureSteps, lookback, paths) {
            const n = history.length;
            const k = Math.max(5, Math.min(lookback, n));
            const slice = history.slice(n - k).map(v => Number(v));
            const deltas = [];
            for (let i = 1; i < slice.length; i += 1) deltas.push(slice[i] - slice[i - 1]);
            const { mean, std } = meanStd(deltas);
            const start = Number(history[n - 1]);

            const perStep = Array.from({ length: futureSteps }, () => []);
            for (let p = 0; p < paths; p += 1) {
                let y = start;
                for (let s = 0; s < futureSteps; s += 1) {
                    y = y + mean + std * randn();
                    perStep[s].push(y);
                }
            }

            const p10 = [];
            const p50 = [];
            const p90 = [];
            for (let s = 0; s < futureSteps; s += 1) {
                const arr = perStep[s].slice().sort((a, b) => a - b);
                p10.push(quantile(arr, 0.10));
                p50.push(quantile(arr, 0.50));
                p90.push(quantile(arr, 0.90));
            }
            return { p10, p50, p90, meanDelta: mean, stdDelta: std };
        }

        let historyChart = null;
        let projectionChart = null;
        let DATA = null;
        let liveChart = null;
        let liveTimer = null;
        let liveInFlight = false;

        function setAdvancedOpen(open) {
            const isOpen = Boolean(open);
            document.body.classList.toggle('advanced-open', isOpen);
            try { localStorage.setItem('sf_full_dashboard_v1', isOpen ? '1' : '0'); } catch {}

            const toggleBtn = document.querySelector('[data-advanced-toggle]');
            if (toggleBtn) toggleBtn.textContent = isOpen ? 'Basic view' : 'Full dashboard';

            if (isOpen) {
                requestAnimationFrame(() => {
                    try { if (historyChart && typeof historyChart.resize === 'function') historyChart.resize(); } catch {}
                    try { if (projectionChart && typeof projectionChart.resize === 'function') projectionChart.resize(); } catch {}
                });

                if (!projectionChart && DATA) {
                    const modelSelect = document.getElementById('projectionModel');
                    renderProjectionChart(modelSelect ? modelSelect.value : 'linear');
                }
            }
        }

        function initAdvancedMenu() {
            const btn = document.getElementById('advancedBtn');
            const menu = document.getElementById('advancedMenu');
            if (!btn || !menu) return;

            const stored = (() => {
                try { return localStorage.getItem('sf_full_dashboard_v1'); } catch { return null; }
            })();
            setAdvancedOpen(stored === '1');

            function close() {
                menu.hidden = true;
                btn.setAttribute('aria-expanded', 'false');
            }

            function open() {
                menu.hidden = false;
                btn.setAttribute('aria-expanded', 'true');
                const toggleBtn = menu.querySelector('[data-advanced-toggle]');
                if (toggleBtn) toggleBtn.textContent = document.body.classList.contains('advanced-open') ? 'Basic view' : 'Full dashboard';
            }

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (menu.hidden) open(); else close();
            });

            menu.addEventListener('click', (e) => {
                e.stopPropagation();
                const t = e.target;
                const toggle = t && t.closest ? t.closest('[data-advanced-toggle]') : null;
                if (toggle) {
                    setAdvancedOpen(!document.body.classList.contains('advanced-open'));
                    close();
                    return;
                }

                const jump = t && t.closest ? t.closest('[data-advanced-jump]') : null;
                if (jump) {
                    const id = jump.getAttribute('data-advanced-jump');
                    setAdvancedOpen(true);
                    close();
                    requestAnimationFrame(() => {
                        const el = id ? document.getElementById(id) : null;
                        if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    });
                }
            });

            document.addEventListener('click', () => close());
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });
        }

	        function renderWeightsTable({ tickers, weights }) {
	            const body = document.getElementById('weightsTableBody');
	            if (!body) return;
            body.innerHTML = '';
            for (const t of tickers) {
                const tr = document.createElement('tr');
                const td1 = document.createElement('td');
                const td2 = document.createElement('td');
                td1.innerHTML = `<code>${t}</code>`;
                td2.textContent = formatPct(weights?.[t]);
                tr.appendChild(td1);
                tr.appendChild(td2);
                body.appendChild(tr);
            }
            const trTotal = document.createElement('tr');
            const tdT1 = document.createElement('td');
            const tdT2 = document.createElement('td');
            tdT1.innerHTML = '<strong>Total</strong>';
            tdT2.innerHTML = `<strong>${formatPct(DATA?.basket?.totalWeight)}</strong>`;
            trTotal.appendChild(tdT1);
            trTotal.appendChild(tdT2);
	            body.appendChild(trTotal);
	        }

	        function updateHistoryNote() {
	            const noteEl = document.getElementById('historyNote');
	            if (!noteEl || !historyChart) return;

	            const labels = Array.isArray(historyChart.data?.labels) ? historyChart.data.labels : [];
	            if (!labels.length) {
	                noteEl.textContent = '';
	                return;
	            }

	            const minOpt = historyChart.options?.scales?.x?.min;
	            const maxOpt = historyChart.options?.scales?.x?.max;
	            const minLabel = (minOpt !== undefined && minOpt !== null) ? labelForCategoryTick(labels, minOpt) : labels[0];
	            const maxLabel = (maxOpt !== undefined && maxOpt !== null) ? labelForCategoryTick(labels, maxOpt) : labels[labels.length - 1];

	            const parts = [`Showing ${formatMonthDayYear(minLabel)} ‚Üí ${formatMonthDayYear(maxLabel)}.`];
	            const denseFrom = DATA?.sampling?.denseFrom;
	            const strideDays = DATA?.sampling?.coarseStrideDays;
	            if (denseFrom && strideDays) {
	                parts.push(`Sampling: daily from ${denseFrom}; older dates downsampled (‚âà every ${strideDays} weekdays).`);
	            }

	            noteEl.textContent = parts.join(' ');
	        }

	        function renderHistoryChart() {
	            const canvas = document.getElementById('historyChart');
	            if (!canvas) return;

            const labels = DATA.series.dates;
            const values = DATA.series.total;

            if (historyChart) { historyChart.destroy(); historyChart = null; }
            const ctx = canvas.getContext('2d');

            historyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Basket weight',
                        data: values,
                        borderColor: '#00d4ff',
                        backgroundColor: 'rgba(0, 212, 255, 0.10)',
                        borderWidth: 3,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        tension: 0.25
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'nearest', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: { label: (c) => ` ${formatPct(c.parsed.y)}` } }
                    },
                    scales: {
                        y: {
                            grid: { color: 'rgba(255,255,255,0.08)' },
                            ticks: { color: '#888', callback: (v) => `${Number(v).toFixed(1)}%` }
                        },
	                        x: {
	                            grid: { display: false },
	                            ticks: { color: '#888', autoSkip: true, maxRotation: 0, callback: (v) => formatMonthDay(labelForCategoryTick(labels, v)) }
	                        }
	                    }
	                }
		            });
	
	            updateHistoryNote();

	            const zoomBtn = document.getElementById('zoomToPeriodBtn');
	            const resetBtn = document.getElementById('resetZoomBtn');
	            if (zoomBtn) zoomBtn.disabled = false;
            if (resetBtn) resetBtn.disabled = false;
        }

	        function applyHistoryZoom({ minIso, maxIso }) {
	            if (!historyChart) return;
	            const labels = historyChart.data.labels || [];
	            const min = clampLabelAfter(labels, minIso);
	            const max = clampLabelBefore(labels, maxIso);
	            historyChart.options.scales.x.min = min;
	            historyChart.options.scales.x.max = max;
	            historyChart.update();
	            updateHistoryNote();
	        }

	        function resetHistoryZoom() {
	            if (!historyChart) return;
	            historyChart.options.scales.x.min = undefined;
	            historyChart.options.scales.x.max = undefined;
	            historyChart.update();
	            updateHistoryNote();
	        }

        function renderProjectionChart(modelKey) {
            const canvas = document.getElementById('projectionChart');
            const noteEl = document.getElementById('projectionNote');
            if (!canvas) return;

            const histDates = DATA.series.dates;
            const histValues = DATA.series.total;
            const lastDate = histDates[histDates.length - 1];

            const futureDates = generateBusinessDates(lastDate, RESOLUTION_DATE);
            const labels = histDates.concat(futureDates);

            const actual = histValues.concat(Array.from({ length: futureDates.length }, () => null));

            const lookback = 60;
            let projection = [];
            let band = null;

            if (futureDates.length === 0) {
                projection = Array.from({ length: labels.length }, () => null);
            } else if (modelKey === 'linear') {
                const future = computeLinearProjection(histValues, futureDates.length, lookback);
                const prefix = Array.from({ length: histValues.length }, () => null);
                prefix[prefix.length - 1] = histValues[histValues.length - 1];
                projection = prefix.concat(future);
            } else if (modelKey === 'exp') {
                const future = computeExpProjection(histValues, futureDates.length, lookback);
                const prefix = Array.from({ length: histValues.length }, () => null);
                prefix[prefix.length - 1] = histValues[histValues.length - 1];
                projection = prefix.concat(future);
            } else {
                const paths = 1200;
                const mc = computeMonteCarlo(histValues, futureDates.length, lookback, paths);
                const prefix = Array.from({ length: histValues.length }, () => null);
                prefix[prefix.length - 1] = histValues[histValues.length - 1];
                projection = prefix.concat(mc.p50);
                band = {
                    p10: prefix.concat(mc.p10),
                    p90: prefix.concat(mc.p90),
                    meanDelta: mc.meanDelta,
                    stdDelta: mc.stdDelta
                };
            }

            if (projectionChart) { projectionChart.destroy(); projectionChart = null; }
            const ctx = canvas.getContext('2d');

            const datasets = [
                {
                    label: 'Actual',
                    data: actual,
                    borderColor: 'rgba(229, 231, 235, 0.70)',
                    borderWidth: 2.5,
                    pointRadius: 0,
                    tension: 0.25,
                    spanGaps: false
                }
            ];

            if (band) {
                datasets.push({
                    label: 'P10',
                    data: band.p10,
                    borderColor: 'rgba(74, 222, 128, 0.0)',
                    backgroundColor: 'rgba(74, 222, 128, 0.10)',
                    pointRadius: 0,
                    tension: 0.25,
                    fill: '+1'
                });
                datasets.push({
                    label: 'P90',
                    data: band.p90,
                    borderColor: 'rgba(74, 222, 128, 0.0)',
                    backgroundColor: 'rgba(74, 222, 128, 0.10)',
                    pointRadius: 0,
                    tension: 0.25,
                    fill: false
                });
            }

            datasets.push({
                label: band ? 'Median (MC)' : 'Projection',
                data: projection,
                borderColor: '#fbbf24',
                borderWidth: 3,
                borderDash: [8, 6],
                pointRadius: 0,
                tension: 0.25,
                spanGaps: true
            });

            projectionChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'nearest', intersect: false },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: { color: '#bbb', usePointStyle: true, boxWidth: 10, padding: 14 }
                        },
                        tooltip: { callbacks: { label: (c) => ` ${c.dataset.label}: ${formatPct(c.parsed.y)}` } }
                    },
                    scales: {
                        y: {
                            grid: { color: 'rgba(255,255,255,0.08)' },
                            ticks: { color: '#888', callback: (v) => `${Number(v).toFixed(1)}%` }
                        },
	                        x: {
	                            grid: { display: false },
	                            ticks: { color: '#888', autoSkip: true, maxRotation: 0, callback: (v) => formatMonthDay(labelForCategoryTick(labels, v)) }
	                        }
	                    }
	                }
	            });

            if (!noteEl) return;
            if (futureDates.length === 0) {
                noteEl.textContent = 'Resolution date is at/before the last available holdings date; no forward projection shown.';
                return;
            }
            if (modelKey === 'mc' && band) {
                noteEl.textContent = `Monte Carlo uses daily basket-weight deltas (lookback ${lookback}d). Mean Œî=${band.meanDelta.toFixed(3)} pp, œÉ=${band.stdDelta.toFixed(3)} pp.`;
                return;
            }
            noteEl.textContent = `Projection model: ${modelKey.toUpperCase()} (lookback ${lookback}d).`;
        }

        function setCards() {
            const totalEl = document.getElementById('currentTotal');
            const asOfEl = document.getElementById('currentAsOf');
            const changeEl = document.getElementById('changeSinceStart');
            const startNote = document.getElementById('startValueNote');
            const daysEl = document.getElementById('daysToResolution');
            const targetAvailEl = document.getElementById('targetAvailability');

            const asOfDate = DATA?.basket?.asOfDate;
            const holdingsLabel = DATA?.basket?.holdingsAsOfLabel;
            const total = DATA?.basket?.totalWeight;
            if (totalEl) totalEl.textContent = formatPct(total);
            if (asOfEl) asOfEl.textContent = holdingsLabel ? `As of ${holdingsLabel}` : (asOfDate ? `As of ${asOfDate}` : 'As of ‚Äî');

            const labels = DATA?.series?.dates || [];
            const totals = DATA?.series?.total || [];
            const startLabel = clampLabelAfter(labels, QUESTION_PERIOD_START);
            const startIdx = startLabel ? labels.indexOf(startLabel) : -1;
            const startValue = startIdx >= 0 ? totals[startIdx] : null;
            const lastValue = totals.length ? totals[totals.length - 1] : null;
            const delta = (Number.isFinite(Number(lastValue)) && Number.isFinite(Number(startValue))) ? (Number(lastValue) - Number(startValue)) : null;
            if (changeEl) changeEl.textContent = formatSignedPctPoints(delta);
            if (startNote) startNote.textContent = startValue === null ? 'Start value unavailable' : `Start (${startLabel}): ${formatPct(startValue)}`;

            const lastObj = asOfDate ? parseISODate(asOfDate) : null;
            const resObj = parseISODate(RESOLUTION_DATE);
            if (daysEl && lastObj && resObj) {
                const diffMs = resObj.getTime() - lastObj.getTime();
                const days = Math.ceil(diffMs / (24 * 60 * 60 * 1000));
                daysEl.textContent = days >= 0 ? `${days} days` : 'Resolved';
            }

            if (targetAvailEl && DATA?.target) {
                if (DATA.target.available) {
                    targetAvailEl.textContent = `Target ${DATA.target.date}: ${formatPct(DATA.target.totalWeight)}`;
                } else {
                    targetAvailEl.textContent = `Target ${DATA.target.date}: not available yet`;
                }
            } else if (targetAvailEl) {
                targetAvailEl.textContent = `Target ${RESOLUTION_DATE}: ‚Äî`;
            }
        }

        function buildHistoryCsv() {
            const rows = [];
            const tickers = DATA?.basket?.tickers || DEFAULT_TICKERS;
            rows.push(['date', 'basket_total', ...tickers.map(t => `${t}_weight`)]);
            const dates = DATA.series.dates;
            for (let i = 0; i < dates.length; i += 1) {
                const row = [dates[i], DATA.series.total[i]];
                for (const t of tickers) row.push(DATA.series.byTicker?.[t]?.[i] ?? null);
                rows.push(row);
            }
            return rows;
        }

        async function fetchData() {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10_000);
            try {
                const todayIso = toISODate(new Date());
                const asof = todayIso > RESOLUTION_DATE ? RESOLUTION_DATE : todayIso;
                const url = `/.netlify/functions/ivv-holdings-weight?months=6&asof=${encodeURIComponent(asof)}&target=${encodeURIComponent(RESOLUTION_DATE)}`;
                const res = await fetch(url, {
                    headers: { 'Accept': 'application/json' },
                    signal: controller.signal
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                if (!data || !data.series || !Array.isArray(data.series.dates)) throw new Error('Bad response');
                return data;
            } finally {
                clearTimeout(timeoutId);
            }
        }

        async function fetchLiveData() {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 12_000);
            try {
                const res = await fetch('/.netlify/functions/ivv-live-basket', {
                    headers: { 'Accept': 'application/json' },
                    signal: controller.signal
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                if (!data || !data.live || !Array.isArray(data.live.timestamps)) throw new Error('Bad response');
                return data;
            } finally {
                clearTimeout(timeoutId);
            }
        }

        function renderLiveChart(liveData) {
            const canvas = document.getElementById('liveChart');
            if (!canvas) return;
            const labels = (liveData?.live?.timestamps || []).map((iso) => formatIntradayLabel(iso));
            const series = liveData?.live?.basketWeight || [];
            if (!labels.length || !series.length) return;

            const ctx = canvas.getContext('2d');
            if (liveChart) {
                liveChart.data.labels = labels;
                liveChart.data.datasets[0].data = series;
                liveChart.update('none');
                return;
            }

            liveChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Live basket weight (est.)',
                            data: series,
                            borderColor: '#00d4ff',
                            borderWidth: 2.4,
                            pointRadius: 0,
                            tension: 0.25
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'nearest', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    const idx = items && items[0] ? items[0].dataIndex : null;
                                    const iso = idx !== null && idx !== undefined ? liveData.live.timestamps[idx] : null;
                                    return iso ? formatIntradayLabel(iso) + ' UTC' : '';
                                },
                                label: (ctx) => `Basket weight: ${formatPct(ctx.parsed.y)}`
                            }
                        }
                    },
                    scales: {
                        y: { grid: { color: 'rgba(255,255,255,0.08)' }, ticks: { color: '#888', callback: (v) => `${Number(v).toFixed(2)}%` } },
                        x: {
                            grid: { display: false },
                            ticks: { color: '#888', autoSkip: true, maxRotation: 0, maxTicksLimit: 8 }
                        }
                    }
                }
            });
        }

        function updateLiveCards(liveData) {
            const nowEl = document.getElementById('liveBasketNow');
            const noteEl = document.getElementById('liveBasketNote');
            const liveNote = document.getElementById('liveNote');
            const latest = liveData?.live?.latest;
            if (nowEl) nowEl.textContent = formatPct(latest?.weight);
            if (noteEl && latest?.timestamp) {
                noteEl.textContent = `As of ${formatIntradayLabel(latest.timestamp)} UTC`;
            }

            if (liveNote) {
                const interval = liveData?.live?.interval || '‚Äî';
                const range = liveData?.live?.range || '‚Äî';
                const holdingsLabel = liveData?.basket?.holdingsAsOfLabel || liveData?.basket?.asOfDate || '‚Äî';
                liveNote.textContent = `Prices: ${range} @ ${interval} (pre/post on) ‚Ä¢ Holdings snapshot: ${holdingsLabel}`;
            }
        }

        async function refreshLive() {
            if (liveInFlight) return;
            liveInFlight = true;
            try {
                const liveData = await fetchLiveData();
                renderLiveChart(liveData);
                updateLiveCards(liveData);
            } catch (e) {
                const liveNote = document.getElementById('liveNote');
                if (liveNote) liveNote.textContent = 'Live data fetch failed. Try again shortly.';
            } finally {
                liveInFlight = false;
            }
        }

        function startLiveUpdates() {
            refreshLive();
            if (liveTimer) clearInterval(liveTimer);
            liveTimer = setInterval(() => {
                if (document.hidden) return;
                refreshLive();
            }, LIVE_REFRESH_MS);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            initAdvancedMenu();
            document.getElementById('resolutionDatePill').textContent = RESOLUTION_DATE;
            document.getElementById('periodStartPill').textContent = QUESTION_PERIOD_START;

            const modelSelect = document.getElementById('projectionModel');
            const zoomBtn = document.getElementById('zoomToPeriodBtn');
            const resetBtn = document.getElementById('resetZoomBtn');
            const dlBtn = document.getElementById('downloadHistoryBtn');

            try {
                DATA = await fetchData();
                const lastUpdatedEl = document.getElementById('lastUpdated');
                if (lastUpdatedEl) lastUpdatedEl.textContent = DATA.lastUpdated || '‚Äî';

                renderWeightsTable({ tickers: DATA.basket.tickers, weights: DATA.basket.weights });
                renderHistoryChart();
                setCards();
                if (document.body.classList.contains('advanced-open')) {
                    renderProjectionChart(modelSelect ? modelSelect.value : 'linear');
                }

                const samplingNote = document.getElementById('samplingNote');
                if (samplingNote && DATA?.sampling) {
                    const denseFrom = DATA.sampling.denseFrom;
                    const strideDays = DATA.sampling.coarseStrideDays;
                    samplingNote.textContent = `Sampling note: for performance, history is daily from ${denseFrom} onward; older dates may be downsampled (‚âà every ${strideDays} weekdays).`;
                }

                if (dlBtn) {
                    dlBtn.disabled = false;
                    dlBtn.addEventListener('click', () => {
                        const asOf = DATA?.basket?.asOfDate || 'asof';
                        downloadCsv(`ivv_basket_weight_${asOf}.csv`, buildHistoryCsv());
                    });
                }
            } catch (e) {
                console.warn('IVV holdings fetch failed', e);
                const lastUpdatedEl = document.getElementById('lastUpdated');
                if (lastUpdatedEl) lastUpdatedEl.textContent = 'Unavailable (stale)';
                const note = document.getElementById('historyNote');
                if (note) note.textContent = 'Live data fetch failed. Try again later.';
                const body = document.getElementById('weightsTableBody');
                if (body) body.innerHTML = '<tr><td colspan="2" class="muted">Live data unavailable</td></tr>';
            }

            startLiveUpdates();

            if (modelSelect) {
                modelSelect.addEventListener('change', () => {
                    if (!DATA) return;
                    if (!document.body.classList.contains('advanced-open')) return;
                    renderProjectionChart(modelSelect.value);
                });
            }

            if (zoomBtn) {
                zoomBtn.addEventListener('click', () => {
                    const end = RESOLUTION_DATE;
                    applyHistoryZoom({ minIso: QUESTION_PERIOD_START, maxIso: end });
                });
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', () => resetHistoryZoom());
            }
        });
    </script>
</body>
</html>
